<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>J.A.R.V.I.S. AI // Gemini Integrated V5</title>
    
    <!-- AI & Vision Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/handtrackjs/dist/handtrack.min.js"></script>

    <style>
        /* --- 1. CORE VARIABLES & THEME --- */
        :root {
            /* Hologram Physics State (Driven by JS) */
            --rx: 0deg;
            --ry: 0deg;
            --scale: 1;
            --breath: 1;
            --explode: 0; 

            /* Dynamic Color Theme */
            --base-h: 180;  /* Cyan Base */
            --base-s: 100%;
            --base-l: 50%;
            --holo-color: hsla(var(--base-h), var(--base-s), var(--base-l), 0.8);
            
            --bg-dark: #050505;
            --panel-bg: rgba(10, 15, 15, 0.85);
        }

        body {
            font-family: 'Segoe UI', 'Courier New', monospace;
            background-color: var(--bg-dark);
            color: var(--holo-color);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            
            /* Sci-Fi Grid Background */
            background-image: 
                linear-gradient(rgba(0, 255, 204, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 204, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 50% 50%, rgba(0, 20, 20, 1) 0%, rgba(5, 5, 5, 1) 80%);
            background-size: 40px 40px, 40px 40px, 100% 100%;
        }

        /* --- 2. HOLOGRAM STAGE (Optimized GPU Layer) --- */
        #stage-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1200px;
        }

        .holo-wrapper {
            position: relative;
            width: 500px; height: 500px;
            transform-style: preserve-3d;
            
            /* PHYSICS LINK: Driven by HoloCore */
            transform: 
                rotateX(var(--rx)) 
                rotateY(var(--ry)) 
                scale(var(--scale));
            
            will-change: transform;
            transition: filter 0.2s ease;
        }

        /* --- ADVANCED GEOMETRY --- */
        .ring {
            position: absolute;
            top: 50%; left: 50%;
            border-radius: 50%;
            transform: translate(-50%, -50%) translateZ(calc(var(--explode) * 1px));
            box-shadow: 0 0 15px var(--holo-color), inset 0 0 10px var(--holo-color);
            transition: border-color 0.2s, box-shadow 0.2s;
            transform-style: preserve-3d;
        }

        /* Main Outer Ring */
        .ring-outer {
            width: 450px; height: 450px;
            border: 1px solid rgba(0, 255, 204, 0.1);
            border-top: 4px solid var(--holo-color);
            border-bottom: 4px solid var(--holo-color);
            animation: spin 30s linear infinite;
        }

        /* Mid Data Ring (Counter-rotating) */
        .ring-mid {
            width: 380px; height: 380px;
            border: 1px dotted rgba(255, 255, 255, 0.3);
            border-left: 2px solid var(--holo-color);
            border-right: 2px solid var(--holo-color);
            animation: spin-rev 20s linear infinite;
            /* Explodes further out */
            transform: translate(-50%, -50%) translateZ(calc(var(--explode) * 2px)) rotateX(45deg);
        }

        /* Inner Precise Ring */
        .ring-inner {
            width: 250px; height: 250px;
            border: 2px dashed rgba(0, 255, 204, 0.4);
            animation: spin 10s linear infinite;
            transform: translate(-50%, -50%) rotateX(90deg);
        }

        /* Scanning Laser Effect */
        .scan-line {
            position: absolute;
            top: 0; left: 10%; right: 10%;
            height: 2px;
            background: var(--holo-color);
            box-shadow: 0 0 20px var(--holo-color);
            animation: scan 3s ease-in-out infinite;
            opacity: 0.7;
            transform: translateZ(calc(var(--explode) * 0.5px));
        }

        .core-cube {
            position: absolute;
            top: 50%; left: 50%;
            width: 80px; height: 80px;
            transform-style: preserve-3d;
            transform: translate(-50%, -50%) scale(var(--breath)) rotateX(45deg) rotateY(45deg);
            will-change: transform;
        }

        .face {
            position: absolute;
            width: 80px; height: 80px;
            border: 2px solid var(--holo-color);
            background: rgba(0, 255, 204, 0.1);
            box-shadow: inset 0 0 20px rgba(0, 255, 204, 0.2);
            backface-visibility: visible; 
        }

        /* Gestural States Visuals */
        .gesture-grabbed .ring { border-color: #ffaa00; box-shadow: 0 0 30px #ffaa00; }
        .gesture-grabbed .face { border-color: #ffaa00; background: rgba(255, 170, 0, 0.3); }
        
        .gesture-pinch .ring { border-style: dotted; }
        .gesture-pinch .holo-wrapper { filter: hue-rotate(90deg); } /* Purple shift */
        
        .gesture-point .holo-wrapper { filter: hue-rotate(-60deg) brightness(1.5); } /* Green shift */
        .gesture-shake .holo-wrapper { animation: glitch 0.2s infinite; }
        .gesture-freeze .holo-wrapper * { animation-play-state: paused !important; filter: grayscale(1); }

        @keyframes glitch {
            0% { transform: skewX(10deg); }
            50% { transform: skewX(-10deg); }
            100% { transform: skewX(10deg); }
        }

        .f-front  { transform: translateZ(40px); }
        .f-back   { transform: rotateY(180deg) translateZ(40px); }
        .f-right  { transform: rotateY(90deg) translateZ(40px); }
        .f-left   { transform: rotateY(-90deg) translateZ(40px); }
        .f-top    { transform: rotateX(90deg) translateZ(40px); }
        .f-bottom { transform: rotateX(-90deg) translateZ(40px); }

        /* --- 3. UI LAYOUT --- */
        #left-panel {
            position: fixed;
            top: 20px; left: 20px;
            width: 250px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #chat-panel {
            position: fixed;
            top: 20px; right: 20px; bottom: 100px;
            width: 350px;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }

        #chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            scrollbar-width: thin;
            scrollbar-color: var(--holo-color) transparent;
            mask-image: linear-gradient(to bottom, transparent, black 10%);
        }

        .message {
            background: rgba(0, 20, 20, 0.6);
            border-left: 2px solid var(--holo-color);
            padding: 10px;
            margin-bottom: 10px;
            font-size: 13px;
            line-height: 1.4;
            animation: fadeIn 0.3s ease;
            backdrop-filter: blur(4px);
        }
        .user-msg { border-color: #fff; text-align: right; background: rgba(50, 50, 50, 0.4); }
        .ai-msg { border-color: var(--holo-color); }
        .sys-msg { border-color: #ffaa00; color: #ffaa00; font-style: italic; font-size: 11px; }

        #input-area {
            position: fixed;
            bottom: 20px; right: 20px;
            width: 350px;
            z-index: 20;
            display: flex;
            gap: 5px;
            align-items: center;
        }

        input[type="text"] {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--holo-color);
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            outline: none;
            letter-spacing: 1px;
        }

        button {
            background: rgba(0, 20, 20, 0.9);
            border: 1px solid var(--holo-color);
            color: var(--holo-color);
            padding: 8px 12px;
            text-transform: uppercase;
            font-size: 11px;
            cursor: pointer;
            letter-spacing: 1px;
            transition: all 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button:hover { background: var(--holo-color); color: #000; }
        button.active { background: var(--holo-color); color: #000; box-shadow: 0 0 15px var(--holo-color); }

        /* Icon Buttons */
        .icon-btn {
            padding: 10px;
            min-width: 40px;
        }
        
        .mic-active {
            animation: pulse-red 1.5s infinite;
            border-color: #ff3333 !important;
            color: #ff3333 !important;
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 51, 51, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 51, 51, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 51, 51, 0); }
        }

        /* Special Gemini Buttons */
        #btn-scan {
            border-color: #4db8ff; color: #4db8ff;
        }
        #btn-scan:hover { background: #4db8ff; color: #000; }

        /* Dropdown Style */
        select.hud-select {
            width: 100%;
            background: rgba(0, 15, 15, 0.9);
            color: var(--holo-color);
            border: 1px solid var(--holo-color);
            padding: 8px;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            outline: none;
            margin-top: 5px;
            cursor: pointer;
        }
        select.hud-select option {
            background: #000;
            color: var(--holo-color);
            padding: 5px;
        }

        #matrix-canvas {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0.1; z-index: -1;
            pointer-events: none;
        }

        @keyframes spin { from { transform: translate(-50%, -50%) rotateZ(0deg); } to { transform: translate(-50%, -50%) rotateZ(360deg); } }
        @keyframes spin-rev { from { transform: translate(-50%, -50%) rotateZ(360deg); } to { transform: translate(-50%, -50%) rotateZ(0deg); } }
        @keyframes scan { 0% { top: 10%; opacity: 0; } 50% { opacity: 1; } 100% { top: 90%; opacity: 0; } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        #video { display: none; }
        
        .hud-header {
            border-bottom: 1px solid var(--holo-color);
            margin-bottom: 10px;
            padding-bottom: 5px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            text-shadow: 0 0 5px var(--holo-color);
        }

        #config-modal {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            background: rgba(10, 15, 15, 0.95);
            border: 1px solid var(--holo-color);
            padding: 20px;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.2);
        }
        #config-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 999; display: none;
            backdrop-filter: blur(5px);
        }
        .warning-text { color: #ff3333; font-size: 10px; margin-top: 5px; }
        
        /* Capture Canvas (Hidden) */
        #cap-canvas { display: none; }
    </style>
</head>
<body>

    <video id="video"></video>
    <canvas id="matrix-canvas"></canvas>
    <canvas id="cap-canvas"></canvas>
    
    <!-- Hidden File Input -->
    <input type="file" id="file-input" accept="image/*" style="display: none;">

    <!-- 3D HOLOGRAM STAGE -->
    <div id="stage-container">
        <div class="holo-wrapper" id="holo-wrapper">
            <!-- Layers of Geometry -->
            <div class="ring ring-outer"></div>
            <div class="ring ring-mid"></div>
            <div class="ring ring-inner"></div>
            <div class="scan-line"></div>
            
            <!-- Core -->
            <div class="core-cube">
                <div class="face f-front"></div>
                <div class="face f-back"></div>
                <div class="face f-right"></div>
                <div class="face f-left"></div>
                <div class="face f-top"></div>
                <div class="face f-bottom"></div>
            </div>
        </div>
    </div>

    <!-- LEFT CONTROLS -->
    <div id="left-panel">
        <div class="hud-header">SYSTEM CONTROLS</div>
        <button id="btn-config">‚ö† SYSTEM CONFIG</button>
        <button id="btn-track">INIT HAND TRACKING</button>
        <button id="btn-scan">‚ú® VISION SCAN (CAM)</button>
        <button id="btn-voice">TTS AUDIO: OFF</button>
        <button id="btn-security">SECURITY: OFF</button>
        <button id="btn-matrix">MATRIX: ON</button>
        
        <!-- GESTURE REFERENCE LIST (INFO ONLY) -->
        <select id="gesture-list" class="hud-select" onchange="this.selectedIndex=0; this.blur();">
            <option value="" disabled selected>‚ñº VIEW GESTURE COMMANDS ‚ñº</option>
            <option disabled>--- HAND STATES ---</option>
            <option>üñê OPEN HAND: Move/Zoom/Rotate</option>
            <option>‚úä FIST: Shrink & Grab (Orange)</option>
            <option>üëå PINCH: Explode View (Purple)</option>
            <option>‚òù POINT: Target Lock (Green)</option>
            <option disabled>--- MOTION GESTURES ---</option>
            <option>‚Üª ROTATE CW: Enlarge Size</option>
            <option>‚Ü∫ ROTATE CCW: Reduce Size</option>
            <option>‚¨Ö SWIPE LEFT: Spin Left</option>
            <option>‚û° SWIPE RIGHT: Spin Right</option>
            <option>‚¨Ü SWIPE UP: Spin Up</option>
            <option>‚¨á SWIPE DOWN: Spin Down</option>
            <option>üí® PUSH: Rapid Zoom In</option>
            <option>üëã PULL: Rapid Zoom Out</option>
            <option>üî≤ CORNERS: Zone Lock</option>
            <option>‚ö° SHAKE: System Glitch</option>
            <option>üåä WAVE: Rainbow Pulse</option>
            <option disabled>--- MULTI-HAND ---</option>
            <option>üëê 2 HANDS OPEN: Maximize</option>
            <option>üëä 2 HANDS FIST: Stealth Mode</option>
            <option>‚ùÑ FREEZE: Stop Physics</option>
        </select>

        <div style="font-size: 10px; margin-top:10px; color:#777;">
            CORE STATUS: <span id="status-text" style="color:var(--holo-color)">ONLINE</span><br>
            GESTURE: <span id="gesture-text" style="color:#fff">NONE</span><br>
            FPS: <span id="fps-counter">60</span>
        </div>
    </div>

    <!-- RIGHT CHAT -->
    <div id="chat-panel">
        <div class="hud-header">COMMUNICATION LOG</div>
        <div id="chat-history">
            <div class="message ai-msg">J.A.R.V.I.S. Core V5.0 Online. Voice & File Systems Active.</div>
        </div>
    </div>

    <div id="input-area">
        <button id="btn-upload" class="icon-btn" title="Upload Image">üìÅ</button>
        <input type="text" id="user-input" placeholder="Type or use voice..." autocomplete="off">
        <button id="btn-mic" class="icon-btn" title="Voice Command">üé§</button>
        <button id="btn-send">SEND</button>
    </div>

    <!-- CONFIG MODAL -->
    <div id="config-overlay"></div>
    <div id="config-modal">
        <div class="hud-header">SECURITY PROTOCOLS</div>
        <div style="font-size:11px; margin-bottom:15px; color:#aaa;">AUTHENTICATION REQUIRED FOR NEURAL LINK</div>
        <input type="password" id="api-key-input" placeholder="ENTER OPENROUTER KEY (sk-or-v1...)" style="width:100%; box-sizing:border-box; margin-bottom:10px; background:#000; color:#fff; border:1px solid #333; padding:8px;">
        <div class="warning-text" id="auth-warning">Authorization Failed. Check Key.</div>
        <div style="display:flex; gap:10px; margin-top:20px;">
            <button id="btn-save-key" style="flex:1;">AUTHENTICATE</button>
            <button id="btn-close-key" style="flex:1; background:transparent; border-color:#555; color:#555;">CANCEL</button>
        </div>
    </div>

    <script>
        // GLOBAL API KEY (Empty by default)
        const DEFAULT_KEY = ""; 
        
        // Initialize Key: Check storage first
        let currentApiKey = localStorage.getItem('jarvis_api_key') || DEFAULT_KEY;
        let pendingCommand = null; // Store message if auth is needed

        /**
         * ------------------------------------------------------------------
         * GEMINI LLM CORE (Via OpenRouter)
         * ------------------------------------------------------------------
         */
        const GeminiCore = {
            endpoint: "https://openrouter.ai/api/v1/chat/completions",
            models: [
                "google/gemini-2.0-flash-lite-preview-02-05:free", 
                "google/gemini-2.0-flash-exp:free", 
                "google/gemini-2.0-flash-001"
            ],
            
            systemInstruction: `You are J.A.R.V.I.S., a highly advanced AI interface.
            1. Roleplay: Be concise, witty, robotic but polite (British influence). Address user as 'Sir'.
            2. UI Control: You have direct control over the interface. If the user asks to change colors, modes, or alerts, you MUST include a JSON block at the VERY END of your response.
            
            JSON Format:
            { "action": "SET_MODE", "value": "ALERT" }
            { "action": "SET_COLOR", "value": 0 }
            { "action": "SCAN_UI", "value": "TRUE" }
            `,

            async sendText(text) {
                return this.tryFetch({
                    messages: [
                        { role: "system", content: this.systemInstruction },
                        { role: "user", content: text + "\n\n(Remember to append JSON command if applicable)" }
                    ]
                });
            },

            async sendImage(base64Image, prompt) {
                return this.tryFetch({
                    messages: [
                        { role: "system", content: this.systemInstruction },
                        { 
                            role: "user", 
                            content: [
                                { type: "text", text: prompt },
                                { type: "image_url", image_url: { url: `data:image/jpeg;base64,${base64Image}` } }
                            ] 
                        }
                    ]
                });
            },

            // Auto-Switch Models on 429/Error
            async tryFetch(payloadBase, modelIndex = 0) {
                if (modelIndex >= this.models.length) {
                    throw new Error("All neural pathways unavailable.");
                }

                if (!currentApiKey) {
                    showConfigModal("API Key Required.");
                    throw new Error("API Key Missing.");
                }

                const currentModel = this.models[modelIndex];
                const payload = { ...payloadBase, model: currentModel };

                try {
                    const response = await fetch(this.endpoint, {
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${currentApiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': 'https://jarvis-ui.com', 
                            'X-Title': 'Jarvis AI'
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        // AUTH ERROR (401)
                        if (response.status === 401) {
                            showConfigModal("Access Denied (401). Invalid Key."); 
                            throw new Error("ACCESS DENIED (401).");
                        }

                        // Rate Limit (429) -> Switch Model
                        if (response.status === 429 || response.status === 503) {
                            console.warn(`Model ${currentModel} failed. Switching...`);
                            return this.tryFetch(payloadBase, modelIndex + 1);
                        }
                        
                        throw new Error(`API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data.choices[0].message.content;
                } catch (e) {
                    if (modelIndex < this.models.length - 1 && !e.message.includes('401')) {
                        return this.tryFetch(payloadBase, modelIndex + 1);
                    }
                    console.error("Gemini Error:", e);
                    throw e;
                }
            },

            executeCommands(response) {
                const jsonMatch = response.match(/\{[\s\S]*\}$/);
                if (jsonMatch) {
                    try {
                        const command = JSON.parse(jsonMatch[0]);
                        if (command.action === "SET_MODE") HoloCore.setMode(command.value);
                        if (command.action === "SET_COLOR") HoloCore.updateTheme(command.value, 100, 50);
                        return response.replace(jsonMatch[0], '').trim();
                    } catch (e) { return response; }
                }
                return response;
            }
        };

        // --- KEY MANAGEMENT UI LOGIC ---
        const configModal = document.getElementById('config-modal');
        const configOverlay = document.getElementById('config-overlay');
        const apiKeyInput = document.getElementById('api-key-input');
        const authWarning = document.getElementById('auth-warning');

        function showConfigModal(msg = "Authorization Required.") {
            configModal.style.display = 'block';
            configOverlay.style.display = 'block';
            authWarning.innerText = msg;
            apiKeyInput.value = currentApiKey;
            apiKeyInput.focus();
        }

        document.getElementById('btn-config').addEventListener('click', () => showConfigModal());
        document.getElementById('btn-close-key').addEventListener('click', () => {
            configModal.style.display = 'none';
            configOverlay.style.display = 'none';
        });

        document.getElementById('btn-save-key').addEventListener('click', () => {
            const newKey = apiKeyInput.value.trim();
            if(newKey) {
                if(!newKey.startsWith('sk-or-v1')) {
                    authWarning.innerText = "Invalid Format. Must start with 'sk-or-v1'.";
                    return;
                }
                currentApiKey = newKey;
                localStorage.setItem('jarvis_api_key', newKey);
                configModal.style.display = 'none';
                configOverlay.style.display = 'none';
                addMessage('AI', 'Identity confirmed. Neural Link established.');
                
                // AUTO RESUME CHAT
                if(pendingCommand) {
                    userInput.value = pendingCommand;
                    handleSend();
                    pendingCommand = null;
                }
            }
        });

        // --- CHAT LOGIC ---
        async function handleSend() {
            const text = userInput.value.trim();
            if (!text) return;
            
            if (!currentApiKey) {
                pendingCommand = text;
                addMessage('AI', '‚ö† AUTHENTICATION REQUIRED. Access restricted.');
                showConfigModal();
                return;
            }

            addMessage('USER', text);
            userInput.value = '';
            
            if(!isSecurityMode) HoloCore.setMode('THINKING');
            sendBtn.disabled = true;
            
            try {
                const rawResponse = await GeminiCore.sendText(text);
                const finalResponse = GeminiCore.executeCommands(rawResponse);
                addMessage('AI', finalResponse);
                speakResponse(finalResponse);
            } catch (err) {
                if(err.message.includes('401')) {
                     pendingCommand = text; // Save for retry
                     addMessage('AI', '‚ö† KEY REVOKED. Please update configuration.');
                } else {
                     addMessage('AI', `Server Error: ${err.message}`);
                }
            }
            
            if(!isSecurityMode && HoloCore.state.mode === 'THINKING') HoloCore.setMode('IDLE');
            sendBtn.disabled = false;
            userInput.focus();
        }

        // --- NEW: VOICE COMMANDS (Web Speech API) ---
        const micBtn = document.getElementById('btn-mic');
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                micBtn.classList.add('mic-active');
                userInput.placeholder = "Listening...";
            };

            recognition.onend = () => {
                micBtn.classList.remove('mic-active');
                userInput.placeholder = "Type or use voice...";
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                userInput.value = transcript;
                setTimeout(() => handleSend(), 500); // Auto-send after delay
            };
            
            micBtn.addEventListener('click', () => {
                if(micBtn.classList.contains('mic-active')) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });
        } else {
            micBtn.style.display = 'none';
            console.log("Web Speech API not supported.");
        }

        // --- NEW: FILE UPLOAD LOGIC ---
        const uploadBtn = document.getElementById('btn-upload');
        const fileInput = document.getElementById('file-input');

        uploadBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Reset input so same file can be selected again
            e.target.value = '';

            addMessage('SYS', `Analyzing file: ${file.name}...`);
            HoloCore.setMode('THINKING');

            const reader = new FileReader();
            reader.onload = async (event) => {
                const base64Raw = event.target.result; 
                // Strip metadata prefix for Gemini if needed, but our GeminiCore usage handles full data URI?
                // Actually openrouter/gemini usually expects just base64 data or url.
                // Let's strip the "data:image/jpeg;base64," part.
                const base64Data = base64Raw.split(',')[1];

                try {
                    const response = await GeminiCore.sendImage(base64Data, "Analyze this uploaded image. Describe it and check for anomalies.");
                    const text = GeminiCore.executeCommands(response);
                    addMessage('AI', text);
                    speakResponse(text);
                } catch (err) {
                    addMessage('AI', 'Image analysis failed: ' + err.message);
                }
                HoloCore.setMode('IDLE');
            };
            reader.readAsDataURL(file);
        });

        /**
         * ------------------------------------------------------------------
         * J.A.R.V.I.S. GESTURE ENGINE
         * Logic to classify complex states from basic inputs
         * ------------------------------------------------------------------
         */
        const GestureEngine = {
            history: [], // For shake detection
            lastX: 0, lastY: 0, lastAngle: 0,
            
            detect: function(x, y, scale, label, numHands) {
                const dx = x - this.lastX;
                const dy = y - this.lastY;
                const speed = Math.sqrt(dx*dx + dy*dy);
                
                if (this.history.length > 5) this.history.shift();
                this.history.push({dx, dy, speed});

                const angle = Math.atan2(y, x);
                let dAngle = angle - this.lastAngle;
                if (dAngle > Math.PI) dAngle -= 2 * Math.PI;
                if (dAngle < -Math.PI) dAngle += 2 * Math.PI;

                this.lastX = x; 
                this.lastY = y;
                this.lastAngle = angle;

                const isTop = y < -0.3;
                const isBottom = y > 0.3;
                const isLeft = x < -0.3;
                const isRight = x > 0.3;
                
                if (numHands > 1) {
                    if (label === 'closed') return 'DOUBLE_CLOSED';
                    return 'DOUBLE_OPEN';
                }

                if (label === 'closed') return 'GRAB_CENTER';
                if (label === 'pinch') return 'PINCH_CENTER';
                if (label === 'point') return 'POINT_CENTER';

                const radius = Math.sqrt(x*x + y*y);
                if (radius > 0.2 && speed > 0.05) {
                    if (dAngle > 0.15) return 'CLOCKWISE';
                    if (dAngle < -0.15) return 'ANTICLOCKWISE';
                }

                let reversals = 0;
                let highSpeed = 0;
                for(let i=1; i<this.history.length; i++) {
                    if (Math.sign(this.history[i].dx) !== Math.sign(this.history[i-1].dx)) reversals++;
                    if (this.history[i].speed > 0.1) highSpeed++;
                }
                
                if (reversals >= 2 && highSpeed >= 3) return 'SHAKE';
                if (reversals >= 1 && speed > 0.08 && speed < 0.2) return 'WAVE';

                if (speed > 0.15) {
                    if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? 'SWIPE_RIGHT' : 'SWIPE_LEFT';
                    else return dy > 0 ? 'SWIPE_DOWN' : 'SWIPE_UP';
                }
                
                if (scale > 2.5) return 'PUSH';
                if (scale < 0.6) return 'PULL';
                if (speed < 0.002) return 'FREEZE';

                if (isTop && isLeft) return 'ZONE_TL';
                if (isTop && isRight) return 'ZONE_TR';
                if (isBottom && isLeft) return 'ZONE_BL';
                if (isBottom && isRight) return 'ZONE_BR';

                return 'HOVER_CENTER';
            }
        };

        /**
         * ------------------------------------------------------------------
         * J.A.R.V.I.S. HOLOCORE
         * High-Performance Physics & Animation Engine
         * ------------------------------------------------------------------
         */
        const HoloCore = {
            config: {
                lerpFactor: 0.08, 
                deadZone: 0.02,
                baseHue: 170
            },
            state: {
                mode: 'IDLE',
                target: { x: 0, y: 0, scale: 1, explode: 0 },
                current: { x: 0, y: 0, scale: 1, explode: 0 },
                velocity: 0, breath: 0, handVisible: false, gesture: 'NONE', sizeMod: 0
            },
            ui: {
                root: document.documentElement,
                status: document.getElementById('status-text'),
                gesture: document.getElementById('gesture-text'),
                wrapper: document.getElementById('holo-wrapper')
            },

            setMode(mode) {
                this.state.mode = mode;
                this.ui.status.innerText = mode;
                switch(mode) {
                    case 'ALERT': this.updateTheme(0, 100, 50); break;
                    case 'THINKING': this.updateTheme(270, 100, 60); break;
                    case 'LISTENING': this.updateTheme(270, 100, 60); break;
                    case 'IDLE': default: this.updateTheme(170, 100, 50);
                }
            },

            updateInput(x, y, scale = 1, hasHand = false, label = 'open', numHands = 1) {
                const s = this.state;
                s.handVisible = hasHand;
                if (hasHand) {
                    const detectedGesture = GestureEngine.detect(x, y, scale, label, numHands);
                    s.gesture = detectedGesture;
                    this.ui.gesture.innerText = detectedGesture;
                    this.applyGesturePhysics(detectedGesture, x, y, scale);
                } else {
                    this.resetPhysics();
                    this.ui.gesture.innerText = "SEARCHING...";
                }
            },

            applyGesturePhysics(gesture, x, y, scale) {
                const s = this.state;
                const t = s.target;
                const wrapper = this.ui.wrapper;
                
                wrapper.classList.remove('gesture-grabbed', 'gesture-pinch', 'gesture-point', 'gesture-shake', 'gesture-freeze');

                if (Math.abs(x - t.x) > this.config.deadZone) t.x = x;
                if (Math.abs(y - t.y) > this.config.deadZone) t.y = y;
                t.explode = 0;

                switch(gesture) {
                    case 'GRAB_CENTER': wrapper.classList.add('gesture-grabbed'); t.scale = 0.3; break;
                    case 'CLOCKWISE': s.sizeMod += 0.02; if(s.sizeMod > 2.0) s.sizeMod = 2.0; t.scale = scale + s.sizeMod; break;
                    case 'ANTICLOCKWISE': s.sizeMod -= 0.02; if(s.sizeMod < -0.5) s.sizeMod = -0.5; t.scale = scale + s.sizeMod; break;
                    case 'PINCH_CENTER': t.explode = 150; wrapper.classList.add('gesture-pinch'); break;
                    case 'POINT_CENTER': wrapper.classList.add('gesture-point'); break;
                    case 'FREEZE': wrapper.classList.add('gesture-freeze'); break;
                    case 'SHAKE': wrapper.classList.add('gesture-shake'); break;
                    case 'WAVE': this.updateTheme((Date.now() / 10) % 360, 100, 60); break;
                    case 'PUSH': t.scale = 3.0; break;
                    case 'PULL': t.scale = 0.5; break;
                    case 'SWIPE_LEFT': t.x = -2; break;
                    case 'SWIPE_RIGHT': t.x = 2; break;
                    case 'SWIPE_UP': t.y = -2; break;
                    case 'SWIPE_DOWN': t.y = 2; break;
                    case 'DOUBLE_OPEN': t.scale = 2.0; t.explode = 50; break;
                    case 'DOUBLE_CLOSED': t.scale = 0; break;
                    case 'ZONE_TL': t.x = -0.8; t.y = -0.8; break;
                    case 'ZONE_TR': t.x = 0.8; t.y = -0.8; break;
                    case 'ZONE_BL': t.x = -0.8; t.y = 0.8; break;
                    case 'ZONE_BR': t.x = 0.8; t.y = 0.8; break;
                    case 'HOVER_CENTER': t.scale = scale + s.sizeMod; break;
                }
            },

            resetPhysics() {
                this.ui.wrapper.className = 'holo-wrapper';
                this.state.target.explode = 0;
            },

            render(deltaTime) {
                const s = this.state;
                const c = s.current;
                const t = s.target;
                
                let f = (s.gesture.includes('SWIPE') || s.gesture.includes('GRAB')) ? 0.2 : this.config.lerpFactor;

                if (s.handVisible) {
                    c.x += (t.x - c.x) * f;
                    c.y += (t.y - c.y) * f;
                    c.scale += (t.scale - c.scale) * f;
                    c.explode += (t.explode - c.explode) * 0.1;
                    const dx = t.x - c.x; const dy = t.y - c.y;
                    s.velocity = Math.sqrt(dx*dx + dy*dy) * 100;
                } else {
                    // Idle Animation (Auto-Drift)
                    c.x += Math.sin(Date.now() * 0.001) * 0.002;
                    c.y += Math.cos(Date.now() * 0.0015) * 0.002;
                    c.scale += (1 - c.scale) * 0.05;
                    c.explode += (0 - c.explode) * 0.05;
                    s.velocity *= 0.95;
                }

                // 2. BREATHING / PULSE
                s.breath += deltaTime * 0.002;
                let breathVal = 1 + Math.sin(s.breath) * 0.05;
                if (s.mode !== 'IDLE') breathVal = 1 + Math.sin(s.breath * 5) * 0.1;

                if (s.mode === 'IDLE') {
                    if (s.gesture === 'GRAB_CENTER') this.ui.root.style.setProperty('--base-h', 30);
                    else if (s.gesture === 'POINT_CENTER') this.ui.root.style.setProperty('--base-h', 120);
                    else if (s.gesture === 'PINCH_CENTER') this.ui.root.style.setProperty('--base-h', 280);
                    else if (s.gesture === 'SHAKE') {}
                    else if (s.gesture === 'WAVE') {}
                    else if (s.velocity > 5) {
                        const shift = Math.min(s.velocity * 3, 60);
                        this.ui.root.style.setProperty('--base-h', this.config.baseHue + shift);
                    } else {
                        const curH = parseFloat(getComputedStyle(this.ui.root).getPropertyValue('--base-h'));
                        if (Math.abs(curH - this.config.baseHue) > 0.5) {
                            this.ui.root.style.setProperty('--base-h', curH + (this.config.baseHue - curH) * 0.05);
                        }
                    }
                }

                this.ui.root.style.setProperty('--ry', `${c.x * 60}deg`);
                this.ui.root.style.setProperty('--rx', `${c.y * -60}deg`);
                this.ui.root.style.setProperty('--scale', c.scale);
                this.ui.root.style.setProperty('--breath', breathVal);
                this.ui.root.style.setProperty('--explode', c.explode);
            },

            updateTheme(h, s, l) {
                this.config.baseHue = h;
                this.ui.root.style.setProperty('--base-h', h);
                this.ui.root.style.setProperty('--base-s', `${s}%`);
                this.ui.root.style.setProperty('--base-l', `${l}%`);
            }
        };

        /**
         * ------------------------------------------------------------------
         * HAND TRACKING (Input System)
         * ------------------------------------------------------------------
         */
        const video = document.getElementById('video');
        const trackBtn = document.getElementById('btn-track');
        let isTracking = false;
        let model = null;
        let lastDetectTime = 0;
        const DETECT_INTERVAL = 1000 / 20;

        const modelParams = {
            flipHorizontal: true,
            imageScaleFactor: 0.6,
            maxNumBoxes: 2,
            iouThreshold: 0.5,
            scoreThreshold: 0.70,
        };

        trackBtn.addEventListener('click', async () => {
            if (!model) {
                trackBtn.innerText = "INITIALIZING SENSORS...";
                trackBtn.disabled = true;
                model = await handTrack.load(modelParams);
                trackBtn.innerText = "TERMINATE TRACKING";
                trackBtn.disabled = false;
                trackBtn.classList.add('active');
                startTracking();
            } else {
                isTracking = !isTracking;
                if (isTracking) {
                    startTracking();
                    trackBtn.innerText = "TERMINATE TRACKING";
                    trackBtn.classList.add('active');
                } else {
                    handTrack.stopVideo(video);
                    trackBtn.innerText = "RESUME TRACKING";
                    trackBtn.classList.remove('active');
                    HoloCore.updateInput(0, 0, 1, false);
                }
            }
        });

        function startTracking() {
            isTracking = true;
            handTrack.startVideo(video).then(status => {
                if (status) detectLoop();
            });
        }

        async function detectLoop() {
            if (!isTracking) return;
            const now = performance.now();
            if (now - lastDetectTime > DETECT_INTERVAL) {
                const predictions = await model.detect(video);
                
                if (predictions.length > 0) {
                    const p = predictions[0];
                    const bbox = p.bbox;
                    const gesture = p.label; 
                    const numHands = predictions.length;

                    const normX = ((bbox[0] + bbox[2]/2) / video.width * 2) - 1;
                    const normY = ((bbox[1] + bbox[3]/2) / video.height * 2) - 1;
                    const scale = 0.8 + (bbox[2] / video.width * 2);
                    
                    HoloCore.updateInput(normX, normY, scale, true, gesture, numHands);
                } else {
                    HoloCore.updateInput(0, 0, 1, false);
                }
                lastDetectTime = now;
            }
            requestAnimationFrame(detectLoop);
        }

        /**
         * ------------------------------------------------------------------
         * CHAT & LOGIC SYSTEM (Gemini Integrated)
         * ------------------------------------------------------------------
         */
        const chatHistory = document.getElementById('chat-history');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('btn-send');
        const securityBtn = document.getElementById('btn-security');
        let isSecurityMode = false;

        // --- VOICE TOGGLE ---
        let isVoiceEnabled = false;
        document.getElementById('btn-voice').addEventListener('click', (e) => {
            isVoiceEnabled = !isVoiceEnabled;
            e.target.innerText = isVoiceEnabled ? "TTS AUDIO: ON" : "TTS AUDIO: OFF";
            e.target.classList.toggle('active');
        });

        // --- GEMINI VISION SCAN ---
        const scanBtn = document.getElementById('btn-scan');
        const capCanvas = document.getElementById('cap-canvas');
        const capCtx = capCanvas.getContext('2d');

        scanBtn.addEventListener('click', async () => {
            if (!currentApiKey) {
                addMessage('AI', '‚ö† AUTH ERROR. Please configure API Key.');
                return;
            }
            
            addMessage('USER', '[INITIATING VISUAL SCAN...]');
            HoloCore.setMode('THINKING');
            
            capCanvas.width = video.videoWidth || 640;
            capCanvas.height = video.videoHeight || 480;
            
            if(video.readyState === video.HAVE_ENOUGH_DATA) {
                capCtx.drawImage(video, 0, 0);
            } else {
                addMessage('AI', '‚ö† Visual sensors offline. Please enable hand tracking camera.');
                HoloCore.setMode('IDLE');
                return;
            }

            const base64 = capCanvas.toDataURL('image/jpeg').split(',')[1];
            
            try {
                const response = await GeminiCore.sendImage(base64, "Analyze this image. Identify key objects, people, and assess any potential security threats. Keep it concise.");
                const text = GeminiCore.executeCommands(response);
                addMessage('AI', text);
                speakResponse(text);
            } catch (e) {
                addMessage('AI', 'Visual processing failed: ' + e.message);
            }
            HoloCore.setMode('IDLE');
        });

        // Security Toggle
        securityBtn.addEventListener('click', () => {
            isSecurityMode = !isSecurityMode;
            if (isSecurityMode) {
                HoloCore.setMode('ALERT');
                securityBtn.innerText = "SECURITY: ARMED";
                securityBtn.classList.add('active');
                addMessage('AI', 'Security protocols engaged. Sentry mode active.');
            } else {
                HoloCore.setMode('IDLE');
                securityBtn.innerText = "SECURITY: OFF";
                securityBtn.classList.remove('active');
                addMessage('AI', 'Security protocols deactivated.');
            }
        });

        function speakResponse(text) {
            if(window.speechSynthesis && isVoiceEnabled) {
                const u = new SpeechSynthesisUtterance(text);
                u.rate = 1.1; u.pitch = 0.9;
                window.speechSynthesis.speak(u);
            }
        }

        function addMessage(sender, text) {
            const div = document.createElement('div');
            div.className = `message ${sender === 'USER' ? 'user-msg' : (sender === 'SYS' ? 'sys-msg' : 'ai-msg')}`;
            div.innerText = text;
            chatHistory.appendChild(div);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        userInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') handleSend(); });
        sendBtn.addEventListener('click', handleSend);

        /**
         * ------------------------------------------------------------------
         * MATRIX BACKGROUND (Optimized)
         * ------------------------------------------------------------------
         */
        const matrixCanvas = document.getElementById('matrix-canvas');
        const ctx = matrixCanvas.getContext('2d');
        let matrixEnabled = true;
        
        document.getElementById('btn-matrix').addEventListener('click', (e) => {
            matrixEnabled = !matrixEnabled;
            e.target.innerText = matrixEnabled ? "MATRIX: ON" : "MATRIX: OFF";
            matrixCanvas.style.display = matrixEnabled ? 'block' : 'none';
        });

        function resizeMatrix() {
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeMatrix);
        resizeMatrix();

        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        const fontSize = 14;
        let drops = [];
        const columns = matrixCanvas.width / fontSize;
        for(let x=0; x<columns; x++) drops[x] = 1;

        let frameCount = 0;
        function drawMatrix() {
            if (!matrixEnabled) return;
            if (frameCount++ % 2 !== 0) return;

            ctx.fillStyle = "rgba(5, 5, 5, 0.05)";
            ctx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            
            ctx.fillStyle = "#0F0"; 
            ctx.font = fontSize + "px monospace";

            for(let i=0; i<drops.length; i++) {
                const text = chars.charAt(Math.floor(Math.random()*chars.length));
                ctx.fillText(text, i*fontSize, drops[i]*fontSize);
                if(drops[i]*fontSize > matrixCanvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
        }

        /**
         * ------------------------------------------------------------------
         * MAIN LOOP
         * ------------------------------------------------------------------
         */
        let lastTime = 0;
        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (document.visibilityState === 'visible') {
                HoloCore.render(deltaTime);
                drawMatrix();
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

    </script>
</body>
</html>
